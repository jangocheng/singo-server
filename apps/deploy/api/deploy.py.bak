__author__ = 'singo'
__datetime__ = '2019/4/28 10:42 AM'


from rest_framework import viewsets, permissions, mixins, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from django.core.cache import cache
from django.conf import settings
import os, time, linecache
from rest_framework.exceptions import APIException
from datetime import datetime

from common.utils import logger, update_cache_value, update_obj
from common.permissions import DevopsPermission, DeployPermission, IsDevopsPermission
from ..models import DeploymentOrder
from common.apis import jenkins_api, saltapi
from ..tasks import start_job, test_start_job, set_step_cache
from ..common import *
from ..models import History



class DeployError(APIException):
    status_code = 403
    default_detail = 'deploy error'
    default_code = 'invalid'


class BaseDeployAPIView(APIView):

    def get_object(self):
        obj = get_object_or_404(DeploymentOrder, pk=self.kwargs.get('pk'))
        self.check_object_permissions(self.request, obj)
        return obj


class DeployJob(BaseDeployAPIView):
    """
    项目上线

    post:
        启动上线

    get:
        获取上线状态
    """
    permission_classes = (permissions.IsAuthenticated, DeployPermission)

    def init_deploy(self, cache_name, order_obj):
        deploy_path = settings.DEPLOY.get('CODE_PATH')
        minion = settings.DEPLOY.get('M_MINION')
        jenkins_job_name = order_obj.project.jenkins_job

        deploy_cache = cache.get(cache_name, {})

        # 避免被重复执行部署
        if deploy_cache.get('is_lock'):
            raise DeployError('该任务已经启动')
        elif order_obj.status != 1:
            raise DeployError('该工单状态不能上线')
        else:
            # 锁定上线
            cache.set(cache_name, {'is_lock': True}, timeout=CACHE_TIMEOUT)

        # 获取jenkins build_number
        if order_obj.type != ROLLBACK:
            # next_build_number = 80
            # queue_id = 1
            steps = ['init job', 'build', 'download package']
            build_number = jenkins_api.get_next_build_number(jenkins_job_name)
            queue_id = jenkins_api.build_job(jenkins_job_name, parameters={'BRANCH': order_obj.branche})
        else:
            try:
                history = History.objects.get(pk=order_obj.content)
                build_number = history.jk_number
                queue_id = -1
            except:
                raise Exception('获取回滚版本失败')

            steps = ['init job', 'download package']

        # 根据sls文件来获取步骤
        try:
            sls_file = os.path.join(deploy_path, order_obj.project.name, 'init.sls')
            cmd = "grep -o desc:.*$ {}|awk -F \"'\" '{{print $2}}'".format(sls_file)
            ret = saltapi.cmd_run(minion, arg=cmd)
            desc = ret['return'][0][minion]
            step_size = len(steps)+len(desc.split('\n'))*order_obj.project.servers.count()
            steps.extend(desc.split('\n'))
        except Exception as e:
            # step_size = len(steps)
            logger.exception(e)

        deploy_cache = {
                          'job_name': order_obj.project.jenkins_job,
                          'status': S_RUNNING,
                          'build_number': build_number,
                          'is_lock': True,
                          'queue_id': queue_id,
                          'log': os.path.join(deploy_path, 'logs', str(time.time())),
                          'current_step': 1,
                          'step_size': step_size,
                          'steps': steps

                  }

        cache.set(cache_name, deploy_cache, timeout=CACHE_TIMEOUT)

        return build_number

    def post(self, request, pk, format=None):
        order_obj = self.get_object()
        try:
            cache_name = 'deploy-{}'.format(order_obj.project.name)
            jenkins_job_name = order_obj.project.jenkins_job
            # cache_name = 'deploy-{}'.format(order_obj.project.name)
            # deploy_cache = cache.get(cache_name, {})
            #
            # # 避免被重复执行部署
            # if deploy_cache.get('is_lock'):
            #     raise DeployError('该任务已经启动')
            # elif order_obj.status != 1:
            #     raise DeployError('该工单状态不能上线')
            # else:
            #     # 锁定上线
            #     cache.set(cache_name, {'is_lock': True}, timeout=CACHE_TIMEOUT)

            # 初始化
            jenkins_build_number = self.init_deploy(cache_name, order_obj)
            #启动任务
            start_job(cache_name, order_obj, request.user.name)
            # 上线中
            update_obj(order_obj, status=D_RUNNING)

        except DeployError as e:
            logger.exception(e)
            raise DeployError(e)
        except Exception as e:
            # update_cache_value(cache_name, deploy_cache, **{'is_lock': False, 'status': S_FAILED})
            update_cache_value(cache_name, **{'is_lock': False, 'status': S_FAILED})
            logger.exception(e)
            return Response({'detail': '启动任务失败'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        return Response({
                            'project_name': order_obj.project.name,
                            'jenkins_job_name': jenkins_job_name,
                            'jenkins_build_number': jenkins_build_number,
                            'type': 'online'
                         })

    def get(self, request, pk, format=None):
        order_obj = self.get_object()
        cache_name = 'deploy-{}'.format(order_obj.project.name)
        data = cache.get(cache_name)
        return Response(data)


class RedeployJob(DeployJob):
    """
    重新上线
    """
    permission_classes = (permissions.IsAuthenticated, IsDevopsPermission)

    def post(self, request, pk, format=None):
        order_obj = self.get_object()

        # 结单大于12小时不能重新上线
        if order_obj.complete_time and (datetime.now()-order_obj.complete_time).total_seconds() > 12*3600:
            raise DeployError('超出重新上线的时间', 400)
        # 只有失败和成功状态的上线单才能重新上线
        elif order_obj.type != ROLLBACK and (order_obj.status == D_SUCCESSFUL or order_obj.status == D_FAILED):
            update_obj(order_obj, **{'status': D_PENDING, 'type': REONLONE, 'result_msg': ''})
            try:
                ret = super(RedeployJob, self).post(request=request, pk=pk, format=format)
            except Exception as e:
                print('===============')
                print('==============')
                print(e)

        raise DeployError('该工单状态或类型不允许重新上线', 400)




class DeployRealtimeLog(BaseDeployAPIView):
    """
    获取上线实时日志
    """
    permission_classes = (permissions.AllowAny,)

    def get(self, request, pk, format=None):
        try:
            order_obj = self.get_object()
            cache_name = 'deploy-{}'.format(order_obj.project.name)
            deploy_cache = cache.get(cache_name, {})
            log_file = deploy_cache.get('log')
            lineno = int(request.GET.get('lineno', 1))

            if not deploy_cache:
                return Response({'detial': '找不到此工单的实时上线信息'}, status=status.HTTP_404_NOT_FOUND)

            linecache.clearcache()
            lines  = linecache.getlines(log_file)[lineno-1:]

            return Response(lines)
        except Exception as e:
            logger.exception(e)
            return Response(status=status.HTTP_400_BAD_REQUEST)


class SaltStateSLSWebhook(BaseDeployAPIView):
    """
    salt state.sls 回调地址,用于汇报当前发布执行到哪一步
    """
    permission_classes = (permissions.AllowAny,)

    def post(self, request, pk, format=None):
        try:
            order_obj = self.get_object()
            cache_name = 'deploy-{}'.format(order_obj.project.name)
            deploy_cache = cache.get(cache_name)

            if not deploy_cache or not deploy_cache.get('is_lock'):
                raise Exception

            set_step_cache(cache_name, deploy_cache)

            return Response(status=status.HTTP_200_OK)
        except Exception as e:
            logger.exception(e)
            return Response(status=status.HTTP_400_BAD_REQUEST)


class Test(APIView):
    permission_classes = (permissions.AllowAny,)

    def get(self, request, format=None):
        update_cache_value('mytest', {'a': 1}, **{'b': 2}, timeout=CACHE_TIMEOUT, c=3)
        data = cache.get('mytest')
        return Response(data, status=200)

    def post(self, request, format=None):
        # ret = saltapi.state_sls(['devops', None], **{
        #     'mods': 'devops-server',
        #     'saltenv': 'deploy'
        # })
        from common.utils import Bcolor
        print(Bcolor.red('start:{}'.format(time.time())))

        rets = saltapi.state_sls(['minion-1'], **{
            'pillar':
                {
                    'order_id':'ba74e384513f4f63b6643727444a8172',
                    'env': 2,
                    'devops_env': 'dev'
                },
            'mods': 'devops-server',
            'saltenv': 'deploy',

        })

        print(Bcolor.green(rets))


        return Response('lemon1913', status=200)

